<html>
	<head>
		<title>TERMES Visilization</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<tr>
    <td>Select a File to Load:</td>
    <td><input type="file" id="fileToLoad"></td>
    <td><button onclick="loadFileAsText()">Load Selected File</button><td>
</tr>
		<script src="js/three.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script type="text/javascript">
			var container, interval,controls,
			camera, scene, renderer,
			projector,agent,agentwireframe,
			mouse3D, isMouseDown = false, onMouseDownPosition,
			gridSize=16, pickedBlock=null,pickedBlockFrame=null,
			robotDirection=2,grid,squareSize=50, robotHeight=20;//up is 0, right is 1, down 2, left 3
			var robotLocation, heightTracker=[];
			function loadFileAsText(){
				 //  var fileToLoad = document.getElementById("fileToLoad").files[0];
				 //
				 //  var fileReader = new FileReader();
				 //  fileReader.onload = function(fileLoadedEvent){
				 //      var textFromFileLoaded = fileLoadedEvent.target.result;
				 //      document.getElementById("inputTextToSave").value = textFromFileLoaded;
				 //  };
				 //
				 // fileReader.readAsText(fileToLoad, "UTF-8");
				 // alert(fileReader);
				 robotLocation= new THREE.Vector3(3,0,6);// x component controls the y component in the 2D grid, z component controls the x component in the 2D grid, both starting from 0
				 init();
				 animate();
			  }


			  function initTrackers(){

				  for(var i=0;i<gridSize;++i){
					  heightTracker[i]=[];
					  for(var j=0;j<gridSize;++j){
						  heightTracker[i][j]=0;
					  }
				  }
			  }

			  function init(){
				  //projector = new THREE.Projector();
				  renderer = new THREE.WebGLRenderer();
				  renderer.setPixelRatio( window.devicePixelRatio );
				  renderer.setSize( window.innerWidth, window.innerHeight );
				  document.body.appendChild( renderer.domElement );

				  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				  camera.position.x = 400;
				  camera.position.z = 200;

				  controls = new THREE.TrackballControls( camera );
				  controls.rotateSpeed = 1.0;
				  controls.zoomSpeed = 1.2;
				  controls.panSpeed = 0.8;
				  controls.noZoom = false;
				  controls.noPan = false;
				  controls.staticMoving = true;
				  controls.dynamicDampingFactor = 0.3;
				  controls.keys = [ 65, 83, 68 ];
				  controls.addEventListener( 'change', render );
				  document.addEventListener( 'keydown', onDocumentKeyDown, false );


				  scene = new THREE.Scene();
				  scene.background = new THREE.Color( 0xffffff );
				  onMouseDownPosition = new THREE.Vector2();

				  grid = new THREE.GridHelper( gridSize*squareSize, gridSize, 0x000000, 0x000000);// first number is the total length of the square and the second one is the number of grids
				  grid.position.y = - 150;
				  grid.position.x = - 150;
				  scene.add( grid );
				  initTrackers();

				  // var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
				  // var geometrytemp = new THREE.Geometry();
				  // geometrytemp.vertices.push(new THREE.Vector3( gridHelper.position.x, -200, gridHelper.position.z) );
				  // geometrytemp.vertices.push(new THREE.Vector3( gridHelper.position.x, -150, gridHelper.position.z) );
				  // var line = new THREE.Line( geometrytemp, material );
				  // scene.add(line);

				  //renderACube(-150,-125,-150);
				 // var agentPos = calculateTopLeftCorner(gridHelper.position,gridSize);
				  renderRobot();
				  pickACube();
				  camera.lookAt( scene.position );
				  render();
			}

			function calculateWorldPosition(location){
				var size = gridSize/2;
				size -=0.5;
				var position = grid.position;
				var posX= position.x +size*squareSize;// plus to let the cube move toward us, minus to push it away
				var posZ= position.z +size*squareSize;
				var posY = position.y;
				posX -=location.x*squareSize;
				posZ -= location.z*squareSize;
				return new THREE.Vector3(posX,posY,posZ);
			}

			function renderACube(xPos,yPos,zPos){
				var geometry = new THREE.BoxGeometry(50,50,50);
				var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
				var cube = new THREE.Mesh( geometry, material );
				cube.position.x=xPos;
				cube.position.y=yPos;
				cube.position.z=zPos;

				var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
				var mat = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 3 } );
				var wireframe = new THREE.LineSegments( geo, mat );
				wireframe.position.x=xPos;
				wireframe.position.y=yPos;
				wireframe.position.z=zPos;
				scene.add( wireframe );
				scene.add(cube);
			}

			function renderRobot(){
				var worldPosition = calculateWorldPosition(robotLocation);
				worldPosition.y += robotHeight/2;
				var geometry = new THREE.BoxGeometry(squareSize,robotHeight,squareSize);
				//var material = new THREE.MeshBasicMaterial( {color: 0xFF0000} );

				var faceMaterials = [ new THREE.MeshBasicMaterial( {color: 0x00ffff} )];
				for(var i=1;i<geometry.faces.length;++i){
					faceMaterials.push(new THREE.MeshBasicMaterial( {color: 0x000000} ));
				}
				agent  = new THREE.Mesh( geometry, faceMaterials );

				//var texture = new THREE.TextureLoader().load( 'truck.bmp' );
				//var material = new THREE.MeshBasicMaterial( { map: texture } );
				//agent = new THREE.Mesh( geometry, material );
				agent.position.x=worldPosition.x;
				agent.position.y=worldPosition.y;
				agent.position.z=worldPosition.z;


				var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
				var mat = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 3 } );
				agentwireframe = new THREE.LineSegments( geo, mat );
				agentwireframe.position.x=worldPosition.x;
				agentwireframe.position.y=worldPosition.y;
				agentwireframe.position.z=worldPosition.z;
				scene.add( agentwireframe );
				scene.add(agent);
			}

			function pickACube(){
				var yPos= agent.position.y+35;
				var xPos = agent.position.x;
				var zPos= agent.position.z;
				var geometry = new THREE.BoxGeometry(50,50,50);
				var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
				pickedBlock = new THREE.Mesh( geometry, material );
				pickedBlock.position.x=xPos;
				pickedBlock.position.y=yPos;
				pickedBlock.position.z=zPos;
				var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
				var mat = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 3 } );
				pickedBlockFrame = new THREE.LineSegments( geo, mat );
				pickedBlockFrame.position.x=xPos;
				pickedBlockFrame.position.y=yPos;
				pickedBlockFrame.position.z=zPos;
				scene.add( pickedBlockFrame );
				scene.add(pickedBlock);
			}

			function render() {

				renderer.render( scene, camera );
			}
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
			}
			function moveOneGridRight(direction){
				if(direction >0){
					if(robotDirection!=1){
						rotate(robotDirection,1);
					}
					agent.position.z -=squareSize;
					agentwireframe.position.z -=squareSize;
					if(pickedBlock!=null&&pickedBlockFrame!=null){
						pickedBlock.position.z -=squareSize;
						pickedBlockFrame.position.z -=squareSize;
					}
				}
				else{
					if(robotDirection!=3){
						rotate(robotDirection,3);
					}
					agent.position.z += squareSize ;
					agentwireframe.position.z+= squareSize;
					if(pickedBlock!=null&&pickedBlockFrame!=null){
						pickedBlock.position.z += squareSize;
						pickedBlockFrame.position.z += squareSize;
					}
				}
				render();
			}
			function moveOneGridUp(direction){
				if(direction >0){
					if(robotDirection!=0){
						rotate(robotDirection,0);
					}
					agent.position.x -= squareSize;
					agentwireframe.position.x -=squareSize;
					if(pickedBlock!=null&&pickedBlockFrame!=null){
						pickedBlock.position.x -=squareSize;
						pickedBlockFrame.position.x -=squareSize;
					}
				}
				else{
					if(robotDirection!=2){
						rotate(robotDirection,2);
					}
					agent.position.x += squareSize;
					agentwireframe.position.x += squareSize;
					if(pickedBlock!=null&&pickedBlockFrame!=null){
						pickedBlock.position.x +=squareSize;
						pickedBlockFrame.position.x +=squareSize;
					}
				}
				render();
			}
			function rotate(from, to){
				if(from == to){

				}
				else{
					var temp = to-from;
					var current = 0;
					var total = temp*Math.PI/2;
					agent.rotateY(-total);//rotate y direction in counterclockwise direction, therefore we need it to be -1*total
					robotDirection=to;
					render();
					// while(current<total){
					// 	current = current +total*0.05;
					// 	agent.rotateY(total*0.05);
					// 	render();
					// 	animate();
					// }
				}

			}
			function putBlockDown(){

			}
			function onDocumentKeyDown( event ) {
				switch( event.keyCode ) {
					case 39: moveOneGridRight(1); //Right Arrow
					break;
					case 37: moveOneGridRight( -1 );//Left Arrow
					break;
					case 38:moveOneGridUp(1);//up Arrow
					break;
					case 40:moveOneGridUp(-1);//down Arrow
					break;
					case 90:rotate(2,3);
					break;
				}
			}

		</script>
	</body>
</html>
